// ============================================================================
// FILE: ImportWizardController.java - FIXED VERSION
// LOCATION: src/main/java/com/eduscheduler/ui/controller/ImportWizardController.java
// ============================================================================
// CRITICAL FIX #4: Fixed property binding errors
// - Removed direct property sets after binding
// - Property bindings now work correctly
// - No more "A bound value cannot be set" exceptions
// ============================================================================

package com.eduscheduler.ui.controller;

import com.eduscheduler.exception.ImportException;
import com.eduscheduler.model.dto.DataIssue;
import com.eduscheduler.model.dto.ImportResult;
import com.eduscheduler.service.FileImportService;
import com.eduscheduler.service.LenientImportService;

import javafx.application.Platform;
import javafx.concurrent.Task;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.nio.file.Files;
import java.util.List;

/**
 * Import Wizard Controller - FIXED VERSION
 * Location:
 * src/main/java/com/eduscheduler/ui/controller/ImportWizardController.java
 * 
 * ‚úÖ FIXED: Property binding errors resolved
 * - Progress bar and label now bind correctly
 * - No more runtime exceptions
 * - Proper lifecycle management
 * 
 * Features:
 * - Multi-step wizard interface
 * - File selection with validation
 * - Entity type selection (Teacher, Student, Course, Room)
 * - Lenient vs Strict import mode toggle
 * - Real-time progress tracking
 * - Detailed import results
 * 
 * @author EduScheduler Pro Team
 * @version 4.0.0 - FIXED BINDING
 * @since 2025-10-18
 */

@Slf4j
@Controller
@RequiredArgsConstructor

public class ImportWizardController {

    // ========================================================================
    // DEPENDENCIES
    // ========================================================================

    private final FileImportService fileImportService;

    @Qualifier("lenientImportService")
    private final LenientImportService lenientImportService;

    // ========================================================================
    // FXML FIELDS - STEP CONTAINERS
    // ========================================================================

    @FXML
    private VBox step1Box;
    @FXML
    private VBox step2Box;
    @FXML
    private VBox step3Box;

    // ========================================================================
    // FXML FIELDS - STEP 1 (FILE SELECTION)
    // ========================================================================

    @FXML
    private TextField filePathField;
    @FXML
    private Button browseButton;
    @FXML
    private VBox fileInfoBox;
    @FXML
    private Label fileNameLabel;
    @FXML
    private Label fileSizeLabel;
    @FXML
    private Label fileTypeLabel;

    // ========================================================================
    // FXML FIELDS - STEP 2 (CONFIGURATION)
    // ========================================================================

    @FXML
    private ComboBox<String> entityTypeComboBox;
    @FXML
    private CheckBox lenientModeCheckBox;
    @FXML
    private Label modeDescriptionLabel;

    // ========================================================================
    // FXML FIELDS - STEP 3 (PROGRESS & RESULTS)
    // ========================================================================

    @FXML
    private ProgressBar progressBar;
    @FXML
    private Label progressLabel;
    @FXML
    private TextArea resultTextArea;
    @FXML
    private VBox resultBox;

    // ========================================================================
    // FXML FIELDS - NAVIGATION BUTTONS
    // ========================================================================

    @FXML
    private Button nextButton;
    @FXML
    private Button backButton;
    @FXML
    private Button cancelButton;
    @FXML
    private Button finishButton;
    @FXML
    private Button importButton;
    @FXML
    private Button viewDataReviewButton;

    // ========================================================================
    // STATE VARIABLES
    // ========================================================================

    private Stage dialogStage;
    private File selectedFile;
    private int currentStep = 1;

    // ‚úÖ CRITICAL: Task reference to manage binding lifecycle
    private Task<ImportResult> currentImportTask;

    // ========================================================================
    // INITIALIZATION
    // ========================================================================

    @FXML
    public void initialize() {
        log.info("====================================");
        log.info("  INITIALIZING IMPORT WIZARD CONTROLLER     ");
        log.info("====================================");

        try {
            setupEntityTypes();
            setupLenientMode();
            setupStep1();
            showStep(1);

            log.info("‚úì ImportWizardController initialized successfully");
            log.info("====================================\n");

        } catch (Exception e) {
            log.error("‚úó Error during initialization", e);
        }
    }

    /**
     * Set the dialog stage
     */
    public void setDialogStage(Stage dialogStage) {
        this.dialogStage = dialogStage;
    }

    /**
     * Setup entity type combo box
     */
    private void setupEntityTypes() {
        if (entityTypeComboBox != null) {
            entityTypeComboBox.getItems().addAll(
                    "Teacher",
                    "Student",
                    "Course",
                    "Room",
                    "Event");
            entityTypeComboBox.setValue("Teacher");
        }
    }

    /**
     * Setup lenient mode checkbox
     */
    private void setupLenientMode() {
        if (lenientModeCheckBox != null) {
            lenientModeCheckBox.setSelected(true); // Default to lenient mode
            lenientModeCheckBox.setOnAction(e -> updateModeDescription());
            updateModeDescription();
        }
    }

    /**
     * Setup step 1 initial state
     */
    private void setupStep1() {
        if (fileInfoBox != null) {
            fileInfoBox.setVisible(false);
        }
        if (nextButton != null) {
            nextButton.setDisable(true);
        }
    }

    /**
     * Update mode description based on checkbox
     */
    private void updateModeDescription() {
        if (modeDescriptionLabel == null)
            return;

        boolean lenient = lenientModeCheckBox.isSelected();
        if (lenient) {
            modeDescriptionLabel.setText(
                    "‚úì Lenient Mode: Auto-generates missing data (IDs, emails, etc.). " +
                            "Records with missing data will be flagged for review.");
            modeDescriptionLabel.setStyle("-fx-text-fill: #4CAF50;");
        } else {
            modeDescriptionLabel.setText(
                    "‚ö†Ô∏è Strict Mode: Rejects records with missing data. " +
                            "Only complete records will be imported.");
            modeDescriptionLabel.setStyle("-fx-text-fill: #FF9800;");
        }
    }

    // ========================================================================
    // NAVIGATION
    // ========================================================================

    /**
     * Show specific step
     */
    private void showStep(int step) {
        currentStep = step;

        // Hide all steps
        if (step1Box != null)
            step1Box.setVisible(false);
        if (step2Box != null)
            step2Box.setVisible(false);
        if (step3Box != null)
            step3Box.setVisible(false);

        // Show selected step
        switch (step) {
            case 1 -> {
                if (step1Box != null)
                    step1Box.setVisible(true);
                if (backButton != null)
                    backButton.setVisible(false);
                if (nextButton != null)
                    nextButton.setVisible(true);
                if (importButton != null)
                    importButton.setVisible(false);
            }
            case 2 -> {
                if (step2Box != null)
                    step2Box.setVisible(true);
                if (backButton != null)
                    backButton.setVisible(true);
                if (nextButton != null)
                    nextButton.setVisible(false);
                if (importButton != null)
                    importButton.setVisible(true);
            }
            case 3 -> {
                if (step3Box != null)
                    step3Box.setVisible(true);
                if (backButton != null)
                    backButton.setVisible(false);
                if (nextButton != null)
                    nextButton.setVisible(false);
                if (importButton != null)
                    importButton.setVisible(false);
            }
        }

        log.debug("Showing step {}", step);
    }

    // ========================================================================
    // BUTTON HANDLERS
    // ========================================================================

    @FXML
    private void handleBrowse() {
        log.info("üìÇ Browse clicked");

        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle("Select File to Import");
        fileChooser.getExtensionFilters().addAll(
                new FileChooser.ExtensionFilter("All Supported", "*.xlsx", "*.xls", "*.csv"),
                new FileChooser.ExtensionFilter("Excel Files", "*.xlsx", "*.xls"),
                new FileChooser.ExtensionFilter("CSV Files", "*.csv"));

        File file = fileChooser.showOpenDialog(dialogStage);
        if (file != null) {
            selectedFile = file;
            filePathField.setText(file.getAbsolutePath());

            // Show file info
            if (fileInfoBox != null) {
                fileInfoBox.setVisible(true);
                fileNameLabel.setText("üìÑ " + file.getName());
                fileSizeLabel.setText("üíæ " + formatFileSize(file.length()));
                fileTypeLabel.setText("üìã " + getFileExtension(file.getName()).toUpperCase());
            }

            // Enable next button
            if (nextButton != null) {
                nextButton.setDisable(false);
            }

            log.info("‚úÖ File selected: {} ({} bytes)", file.getName(), file.length());
        } else {
            log.info("‚ùå File selection cancelled");
        }
    }

    @FXML
    private void handleNext() {
        log.info("‚û°Ô∏è Next clicked - Step {} ‚Üí Step {}", currentStep, currentStep + 1);

        if (currentStep == 1 && selectedFile != null) {
            showStep(2);
        }
    }

    @FXML
    private void handleBack() {
        log.info("‚¨ÖÔ∏è Back clicked - Step {} ‚Üí Step {}", currentStep, currentStep - 1);

        if (currentStep == 2) {
            showStep(1);
        }
    }

    // ========================================================================
    // ‚úÖ FIXED: IMPORT HANDLER WITH PROPER BINDING
    // ========================================================================

    @FXML
    private void handleImport() {
        log.info("====================================");
        log.info("   STARTING IMPORT PROCESS ");
        log.info("====================================");

        // Validation
        if (selectedFile == null) {
            showError("No File Selected", "Please select a file to import.");
            return;
        }

        String entityType = entityTypeComboBox.getValue();
        if (entityType == null) {
            showError("No Entity Type", "Please select an entity type.");
            return;
        }

        log.info("Import clicked");
        log.info("Entity Type: {}", entityType);
        log.info("File: {}", selectedFile.getName());

        boolean lenientMode = lenientModeCheckBox != null && lenientModeCheckBox.isSelected();
        log.info("Import Mode: {}", lenientMode ? "LENIENT" : "STRICT");

        showStep(3);

        // ‚úÖ CRITICAL FIX: Create task ONCE and manage binding lifecycle
        currentImportTask = new Task<>() {
            @Override
            protected ImportResult call() throws Exception {
                updateMessage("Reading file...");
                updateProgress(10, 100);

                MultipartFile multipartFile = new MockMultipartFile(
                        selectedFile.getName(),
                        selectedFile.getName(),
                        Files.probeContentType(selectedFile.toPath()),
                        new FileInputStream(selectedFile));

                updateMessage("Importing " + entityType + "...");
                updateProgress(30, 100);

                ImportResult result;

                if (lenientMode) {
                    result = switch (entityType.toLowerCase()) {
                        case "teacher" -> lenientImportService.importTeachersLenient(multipartFile);
                        case "student" -> lenientImportService.importStudentsLenient(multipartFile);
                        case "course" -> lenientImportService.importCoursesLenient(multipartFile);
                        case "room" -> lenientImportService.importRoomsLenient(multipartFile);
                        case "event" -> fileImportService.importEvents(multipartFile); // No lenient version yet
                        default -> throw new ImportException("Unknown entity type: " + entityType);
                    };
                } else {
                    result = switch (entityType.toLowerCase()) {
                        case "teacher" -> fileImportService.importTeachers(multipartFile);
                        case "student" -> fileImportService.importStudents(multipartFile);
                        case "course" -> fileImportService.importCourses(multipartFile);
                        case "room" -> fileImportService.importRooms(multipartFile);
                        case "event" -> fileImportService.importEvents(multipartFile);
                        default -> throw new ImportException("Unknown entity type: " + entityType);
                    };
                }

                updateProgress(80, 100);
                updateMessage("Import completed!");
                updateProgress(100, 100);

                return result;
            }

            @Override
            protected void succeeded() {
                super.succeeded();
                ImportResult result = getValue();

                log.info("‚úì Import completed successfully");
                log.info("  - Success: {}", result.getSuccessCount());
                log.info("  - Errors: {}", result.getErrorCount());
                log.info("  - Warnings: {}", result.getWarningCount());

                // ‚úÖ FIXED: Unbind BEFORE updating UI
                unbindProgress();

                // Display results
                displayImportResults(result);
            }

            @Override
            protected void failed() {
                super.failed();
                Throwable error = getException();
                log.error("‚úó Import failed", error);

                // ‚úÖ FIXED: Unbind BEFORE updating UI
                unbindProgress();

                Platform.runLater(() -> {
                    progressLabel.setText("‚ùå Import Failed");
                    progressBar.setProgress(0);

                    String errorMessage = "‚ùå Import failed:\n\n" + error.getMessage();
                    if (error.getMessage().contains("rollback")) {
                        errorMessage += "\n\nüí° Tip: Try enabling 'Lenient Mode' to auto-generate missing data.";
                    }

                    resultTextArea.setText(errorMessage);
                    if (finishButton != null) {
                        finishButton.setVisible(true);
                        finishButton.setDisable(false);
                    }
                });
            }
        };

        // ‚úÖ FIXED: Bind properties ONLY ONCE
        progressBar.progressProperty().bind(currentImportTask.progressProperty());
        progressLabel.textProperty().bind(currentImportTask.messageProperty());

        // Start import thread
        Thread importThread = new Thread(currentImportTask);
        importThread.setDaemon(true);
        importThread.start();
    }

    /**
     * ‚úÖ CRITICAL: Unbind progress properties before manual updates
     */
    private void unbindProgress() {
        Platform.runLater(() -> {
            if (progressBar != null) {
                progressBar.progressProperty().unbind();
            }
            if (progressLabel != null) {
                progressLabel.textProperty().unbind();
            }
        });
    }

    /**
     * Display import results
     */
    private void displayImportResults(ImportResult result) {
        Platform.runLater(() -> {
            StringBuilder message = new StringBuilder();

            message.append("====================================\n");
            message.append("   IMPORT COMPLETED SUCCESSFULLY  \n");
            message.append("====================================\n\n");

            message.append("üìä SUMMARY:\n");
            message.append(String.format("   ‚úÖ Success: %d records\n", result.getSuccessCount()));
            message.append(String.format("   ‚ùå Errors: %d records\n", result.getErrorCount()));
            message.append(String.format("   ‚ö†Ô∏è  Warnings: %d records\n", result.getWarningCount()));
            message.append(String.format("   ‚è≠Ô∏è  Skipped: %d records\n", result.getSkippedCount()));
            message.append(String.format("   üìù Incomplete: %d records\n", result.getIncompleteRecords().size()));

            if (!result.getIncompleteRecords().isEmpty()) {
                message.append("\nüí° TIP: Incomplete records were saved but need review.\n");
                message.append("   Go to Data Management ‚Üí Data Review\n");
                message.append("   to complete missing information.\n");
            }

            if (!result.getIncompleteRecords().isEmpty()) {
                message.append("\n====================================\n");
                message.append("     INCOMPLETE RECORDS\n");
                message.append("====================================\n\n");

                List<DataIssue> issues = result.getIncompleteRecords();
                int displayCount = Math.min(10, issues.size());

                for (int i = 0; i < displayCount; i++) {
                    DataIssue issue = issues.get(i);
                    message.append("‚Ä¢ Row ").append(issue.getRowNumber())
                            .append(": ").append(issue.getIdentifier())
                            .append("\n  Missing: ").append(String.join(", ", issue.getMissingFields()))
                            .append("\n\n");
                }

                if (issues.size() > displayCount) {
                    message.append("... and ").append(issues.size() - displayCount)
                            .append(" more records\n");
                }
            }

            if (!result.getErrors().isEmpty()) {
                message.append("\n====================================\n");
                message.append("          ERROR DETAILS\n");
                message.append("======================================\n\n");

                int errorDisplayCount = Math.min(5, result.getErrors().size());
                for (int i = 0; i < errorDisplayCount; i++) {
                    message.append("‚Ä¢ ").append(result.getErrors().get(i)).append("\n");
                }

                if (result.getErrors().size() > errorDisplayCount) {
                    message.append("... and ").append(result.getErrors().size() - errorDisplayCount)
                            .append(" more errors\n");
                }
            }

            resultTextArea.setText(message.toString());

            if (finishButton != null) {
                finishButton.setVisible(true);
                finishButton.setDisable(false);
            }

            if (viewDataReviewButton != null && !result.getIncompleteRecords().isEmpty()) {
                viewDataReviewButton.setVisible(true);
            }
        });
    }

    @FXML
    private void handleCancel() {
        log.info("‚ùå Cancel clicked");
        closeDialog();
    }

    @FXML
    private void handleFinish() {
        log.info("‚úÖ Finish clicked");
        closeDialog();
    }

    @FXML
    private void handleViewDataReview() {
        log.info("üìã View Data Review clicked");
        showInfo("Data Review",
                "Data Review screen will open here.\n" +
                        "You'll be able to review and complete missing information.");
    }

    // ========================================================================
    // HELPER METHODS
    // ========================================================================

    /**
     * Format file size for display
     */
    private String formatFileSize(long bytes) {
        if (bytes < 1024)
            return bytes + " B";
        if (bytes < 1024 * 1024)
            return String.format("%.1f KB", bytes / 1024.0);
        return String.format("%.1f MB", bytes / (1024.0 * 1024.0));
    }

    /**
     * Get file extension
     */
    private String getFileExtension(String filename) {
        int lastDot = filename.lastIndexOf('.');
        if (lastDot > 0) {
            return filename.substring(lastDot + 1);
        }
        return "";
    }

    /**
     * Close dialog
     */
    private void closeDialog() {
        if (dialogStage != null) {
            dialogStage.close();
        }
    }

    /**
     * Show error alert
     */
    private void showError(String title, String message) {
        Platform.runLater(() -> {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle(title);
            alert.setHeaderText(null);
            alert.setContentText(message);
            alert.showAndWait();
        });
    }

    /**
     * Show info alert
     */
    private void showInfo(String title, String message) {
        Platform.runLater(() -> {
            Alert alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle(title);
            alert.setHeaderText(null);
            alert.setContentText(message);
            alert.showAndWait();
        });
    }

    // ========================================================================
    // MOCK MULTIPART FILE (for converting File to MultipartFile)
    // ========================================================================

    private static class MockMultipartFile implements MultipartFile {
        private final String name;
        private final String originalFilename;
        private final String contentType;
        private final InputStream inputStream;

        public MockMultipartFile(String name, String originalFilename, String contentType,
                InputStream inputStream) {
            this.name = name;
            this.originalFilename = originalFilename;
            this.contentType = contentType;
            this.inputStream = inputStream;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public String getOriginalFilename() {
            return originalFilename;
        }

        @Override
        public String getContentType() {
            return contentType;
        }

        @Override
        public boolean isEmpty() {
            return false;
        }

        @Override
        public long getSize() {
            try {
                return inputStream.available();
            } catch (IOException e) {
                return 0;
            }
        }

        @Override
        public byte[] getBytes() throws IOException {
            return inputStream.readAllBytes();
        }

        @Override
        public InputStream getInputStream() {
            return inputStream;
        }

        @Override
        public void transferTo(java.io.File dest) throws IOException {
            Files.copy(inputStream, dest.toPath());
        }
    }
}