package com.eduscheduler.service.impl;

import com.eduscheduler.model.domain.*;
import com.eduscheduler.model.dto.Conflict;
import com.eduscheduler.model.enums.DayType;
import com.eduscheduler.repository.ScheduleRepository;
import com.eduscheduler.repository.ScheduleSlotRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.DayOfWeek;
import java.time.LocalTime;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Comprehensive Test Suite for ConflictDetectionServiceImpl
 *
 * Service: 17th of 65 services
 * File: src/test/java/com/eduscheduler/service/impl/ConflictDetectionServiceImplTest.java
 *
 * Tests cover:
 * - Conflict detection by schedule ID and object
 * - Teacher conflict detection (double-booking)
 * - Room conflict detection (double-booking)
 * - Capacity violations
 * - Time slot overlap detection
 * - Move conflict checking
 * - Resolution suggestions
 * - Manual override conflict detection
 * - Edge cases and null handling
 *
 * @author EduScheduler Pro Testing Team
 * @version 1.0.0
 * @since December 19, 2025
 */
@ExtendWith(MockitoExtension.class)
class ConflictDetectionServiceImplTest {

    @Mock(lenient = true)
    private ScheduleRepository scheduleRepository;

    @Mock(lenient = true)
    private ScheduleSlotRepository scheduleSlotRepository;

    @InjectMocks
    private ConflictDetectionServiceImpl service;

    private Schedule testSchedule;
    private ScheduleSlot testSlot1;
    private ScheduleSlot testSlot2;
    private Teacher testTeacher;
    private Room testRoom;
    private Course testCourse;
    private TimeSlot testTimeSlot;

    @BeforeEach
    void setUp() {
        // Create test teacher
        testTeacher = new Teacher();
        testTeacher.setId(1L);
        testTeacher.setFirstName("John");
        testTeacher.setLastName("Doe");
        testTeacher.setActive(true);

        // Create test room
        testRoom = new Room();
        testRoom.setId(1L);
        testRoom.setRoomNumber("101");
        testRoom.setCapacity(30);

        // Create test course
        testCourse = new Course();
        testCourse.setId(1L);
        testCourse.setCourseCode("MATH101");
        testCourse.setCourseName("Algebra I");

        // Create test schedule
        testSchedule = new Schedule();
        testSchedule.setId(1L);
        testSchedule.setScheduleName("Fall 2025");

        // Create test schedule slot 1
        testSlot1 = new ScheduleSlot();
        testSlot1.setId(1L);
        testSlot1.setSchedule(testSchedule);
        testSlot1.setTeacher(testTeacher);
        testSlot1.setRoom(testRoom);
        testSlot1.setCourse(testCourse);
        testSlot1.setDayOfWeek(DayOfWeek.MONDAY);
        testSlot1.setStartTime(LocalTime.of(9, 0));
        testSlot1.setEndTime(LocalTime.of(10, 0));
        testSlot1.setPeriodNumber(1);
        testSlot1.setDayType(DayType.DAILY);
        testSlot1.setEnrolledStudents(25);

        // Create test schedule slot 2 (conflicting time)
        testSlot2 = new ScheduleSlot();
        testSlot2.setId(2L);
        testSlot2.setSchedule(testSchedule);
        testSlot2.setTeacher(testTeacher);
        testSlot2.setRoom(testRoom);
        testSlot2.setCourse(testCourse);
        testSlot2.setDayOfWeek(DayOfWeek.MONDAY);
        testSlot2.setStartTime(LocalTime.of(9, 30)); // Overlaps with slot1
        testSlot2.setEndTime(LocalTime.of(10, 30));
        testSlot2.setPeriodNumber(1);
        testSlot2.setDayType(DayType.DAILY);
        testSlot2.setEnrolledStudents(20);

        // Create test time slot
        testTimeSlot = new TimeSlot();
        testTimeSlot.setId(1L);
        testTimeSlot.setDayOfWeek(DayOfWeek.TUESDAY);
        testTimeSlot.setStartTime(LocalTime.of(10, 0));
        testTimeSlot.setEndTime(LocalTime.of(11, 0));
    }

    // ========== DETECT CONFLICTS BY SCHEDULE ID ==========

    @Test
    void testDetectConflictsByScheduleId_WithValidSchedule_ShouldReturnConflicts() {
        when(scheduleRepository.findById(1L)).thenReturn(Optional.of(testSchedule));
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<Conflict> result = service.detectConflicts(1L);

        assertNotNull(result);
        // Should detect teacher and room conflicts due to overlapping times
        assertTrue(result.size() >= 2);
    }

    @Test
    void testDetectConflictsByScheduleId_WithNullScheduleId_ShouldReturnEmptyList() {
        List<Conflict> result = service.detectConflicts((Long) null);

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(scheduleRepository, never()).findById(anyLong());
    }

    @Test
    void testDetectConflictsByScheduleId_WithNonExistentSchedule_ShouldReturnEmptyList() {
        when(scheduleRepository.findById(999L)).thenReturn(Optional.empty());

        List<Conflict> result = service.detectConflicts(999L);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // ========== DETECT CONFLICTS BY SCHEDULE OBJECT ==========

    @Test
    void testDetectConflictsBySchedule_WithValidSchedule_ShouldReturnConflicts() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        assertTrue(result.size() >= 2); // Teacher and room conflicts
    }

    @Test
    void testDetectConflictsBySchedule_WithNullSchedule_ShouldReturnEmptyList() {
        List<Conflict> result = service.detectConflicts((Schedule) null);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testDetectConflictsBySchedule_WithNullScheduleId_ShouldReturnEmptyList() {
        testSchedule.setId(null);

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testDetectConflictsBySchedule_WithNoSlots_ShouldReturnEmptyList() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Collections.emptyList());

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // ========== DETECT ALL CONFLICTS (STRING FORMAT) ==========

    @Test
    void testDetectAllConflicts_WithValidSchedule_ShouldReturnStringList() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<String> result = service.detectAllConflicts(testSchedule);

        assertNotNull(result);
        assertFalse(result.isEmpty());
        // Should contain emoji indicators (ðŸ”´ for HIGH severity)
        assertTrue(result.stream().anyMatch(s -> s.contains("ðŸ”´")));
    }

    @Test
    void testDetectAllConflicts_WithNullSchedule_ShouldReturnEmptyList() {
        List<String> result = service.detectAllConflicts(null);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testDetectAllConflicts_WithNullScheduleId_ShouldReturnEmptyList() {
        testSchedule.setId(null);

        List<String> result = service.detectAllConflicts(testSchedule);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // ========== CHECK SLOT CONFLICTS ==========

    @Test
    void testCheckSlotConflicts_WithValidSlot_ShouldReturnConflicts() {
        when(scheduleSlotRepository.findById(1L)).thenReturn(Optional.of(testSlot1));
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<Conflict> result = service.checkSlotConflicts(1L);

        assertNotNull(result);
        // Should detect conflicts with overlapping slot2
    }

    @Test
    void testCheckSlotConflicts_WithNullSlotId_ShouldReturnEmptyList() {
        List<Conflict> result = service.checkSlotConflicts(null);

        assertNotNull(result);
        assertTrue(result.isEmpty());
        verify(scheduleSlotRepository, never()).findById(anyLong());
    }

    @Test
    void testCheckSlotConflicts_WithNonExistentSlot_ShouldReturnEmptyList() {
        when(scheduleSlotRepository.findById(999L)).thenReturn(Optional.empty());

        List<Conflict> result = service.checkSlotConflicts(999L);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // ========== CHECK MOVE CONFLICTS ==========

    @Test
    void testCheckMoveConflicts_WithValidMove_ShouldReturnConflicts() {
        // Create conflicting slot at the new time
        ScheduleSlot conflictingSlot = new ScheduleSlot();
        conflictingSlot.setId(3L);
        conflictingSlot.setSchedule(testSchedule);
        conflictingSlot.setTeacher(testTeacher);
        conflictingSlot.setRoom(testRoom);
        conflictingSlot.setDayOfWeek(DayOfWeek.TUESDAY);
        conflictingSlot.setStartTime(LocalTime.of(10, 0));
        conflictingSlot.setEndTime(LocalTime.of(11, 0));

        when(scheduleSlotRepository.findByScheduleId(1L))
            .thenReturn(Arrays.asList(testSlot1, conflictingSlot));

        List<Conflict> result = service.checkMoveConflicts(testSlot1, testTimeSlot);

        assertNotNull(result);
        // Should detect conflicts with the existing slot at new time
        assertFalse(result.isEmpty());
    }

    @Test
    void testCheckMoveConflicts_WithNullSlot_ShouldReturnEmptyList() {
        List<Conflict> result = service.checkMoveConflicts(null, testTimeSlot);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testCheckMoveConflicts_WithNullTimeSlot_ShouldReturnEmptyList() {
        List<Conflict> result = service.checkMoveConflicts(testSlot1, null);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testCheckMoveConflicts_WithNullTeacher_ShouldSkipTeacherCheck() {
        testSlot1.setTeacher(null);

        List<Conflict> result = service.checkMoveConflicts(testSlot1, testTimeSlot);

        assertNotNull(result);
        // Should not crash, only check room conflicts
    }

    @Test
    void testCheckMoveConflicts_WithNullRoom_ShouldSkipRoomCheck() {
        testSlot1.setRoom(null);

        List<Conflict> result = service.checkMoveConflicts(testSlot1, testTimeSlot);

        assertNotNull(result);
        // Should not crash, only check teacher conflicts
    }

    @Test
    void testCheckMoveConflicts_WithNullSchedule_ShouldReturnEmptyList() {
        testSlot1.setSchedule(null);

        List<Conflict> result = service.checkMoveConflicts(testSlot1, testTimeSlot);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // ========== RESOLUTION SUGGESTIONS ==========

    @Test
    void testGetResolutionSuggestions_ForTeacherConflict_ShouldReturnSuggestions() {
        Conflict conflict = new Conflict();
        conflict.setConflictType("TEACHER_CONFLICT");
        conflict.setSeverity("HIGH");

        List<String> result = service.getResolutionSuggestions(conflict);

        assertNotNull(result);
        assertEquals(3, result.size());
        assertTrue(result.stream().anyMatch(s -> s.contains("teacher")));
    }

    @Test
    void testGetResolutionSuggestions_ForRoomConflict_ShouldReturnSuggestions() {
        Conflict conflict = new Conflict();
        conflict.setConflictType("ROOM_CONFLICT");
        conflict.setSeverity("HIGH");

        List<String> result = service.getResolutionSuggestions(conflict);

        assertNotNull(result);
        assertEquals(3, result.size());
        assertTrue(result.stream().anyMatch(s -> s.contains("room")));
    }

    @Test
    void testGetResolutionSuggestions_ForCapacityConflict_ShouldReturnSuggestions() {
        Conflict conflict = new Conflict();
        conflict.setConflictType("CAPACITY_CONFLICT");
        conflict.setSeverity("MEDIUM");

        List<String> result = service.getResolutionSuggestions(conflict);

        assertNotNull(result);
        assertEquals(3, result.size());
        assertTrue(result.stream().anyMatch(s -> s.contains("room") || s.contains("enrollment")));
    }

    @Test
    void testGetResolutionSuggestions_ForUnknownConflict_ShouldReturnDefaultSuggestion() {
        Conflict conflict = new Conflict();
        conflict.setConflictType("UNKNOWN_TYPE");
        conflict.setSeverity("LOW");

        List<String> result = service.getResolutionSuggestions(conflict);

        assertNotNull(result);
        assertEquals(1, result.size());
        assertTrue(result.get(0).contains("Manually review"));
    }

    // ========== AUTO RESOLVE CONFLICTS ==========

    @Test
    void testAutoResolveConflicts_WithNoConflicts_ShouldReturnTrue() {
        when(scheduleRepository.findById(1L)).thenReturn(Optional.of(testSchedule));
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Collections.emptyList());

        boolean result = service.autoResolveConflicts(1L);

        assertTrue(result);
    }

    @Test
    void testAutoResolveConflicts_WithConflicts_ShouldReturnFalse() {
        when(scheduleRepository.findById(1L)).thenReturn(Optional.of(testSchedule));
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        boolean result = service.autoResolveConflicts(1L);

        assertFalse(result);
    }

    // ========== TEACHER CONFLICT DETECTION ==========

    @Test
    void testHasTeacherConflict_WithOverlappingSlots_ShouldReturnTrue() {
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1, testSlot2));

        boolean result = service.hasTeacherConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(9, 0),
            LocalTime.of(10, 0));

        assertTrue(result);
    }

    @Test
    void testHasTeacherConflict_WithNoOverlap_ShouldReturnFalse() {
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasTeacherConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(11, 0),
            LocalTime.of(12, 0));

        assertFalse(result);
    }

    @Test
    void testHasTeacherConflict_WithDifferentDay_ShouldReturnFalse() {
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasTeacherConflict(
            1L,
            DayOfWeek.TUESDAY,
            LocalTime.of(9, 0),
            LocalTime.of(10, 0));

        assertFalse(result);
    }

    @Test
    void testHasTeacherConflict_WithNullTeacher_ShouldNotCrash() {
        testSlot1.setTeacher(null);
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasTeacherConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(9, 0),
            LocalTime.of(10, 0));

        assertFalse(result);
    }

    @Test
    void testHasTeacherConflict_WithNullDayOfWeek_ShouldNotCrash() {
        testSlot1.setDayOfWeek(null);
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasTeacherConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(9, 0),
            LocalTime.of(10, 0));

        assertFalse(result);
    }

    // ========== ROOM CONFLICT DETECTION ==========

    @Test
    void testHasRoomConflict_WithOverlappingSlots_ShouldReturnTrue() {
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1, testSlot2));

        boolean result = service.hasRoomConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(9, 0),
            LocalTime.of(10, 0));

        assertTrue(result);
    }

    @Test
    void testHasRoomConflict_WithNoOverlap_ShouldReturnFalse() {
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasRoomConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(11, 0),
            LocalTime.of(12, 0));

        assertFalse(result);
    }

    @Test
    void testHasRoomConflict_WithNullRoom_ShouldNotCrash() {
        testSlot1.setRoom(null);
        when(scheduleSlotRepository.findAll()).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasRoomConflict(
            1L,
            DayOfWeek.MONDAY,
            LocalTime.of(9, 0),
            LocalTime.of(10, 0));

        assertFalse(result);
    }

    // ========== MANUAL OVERRIDE CONFLICT DETECTION ==========

    @Test
    void testDetectConflictsManual_WithTeacherConflict_ShouldReturnConflictString() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        List<String> result = service.detectConflicts(testSlot1, testTeacher, testRoom);

        assertNotNull(result);
        // Should detect teacher conflict (same teacher, same period)
        assertTrue(result.stream().anyMatch(s -> s.contains("Teacher")));
    }

    @Test
    void testDetectConflictsManual_WithRoomConflict_ShouldReturnConflictString() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        List<String> result = service.detectConflicts(testSlot1, testTeacher, testRoom);

        assertNotNull(result);
        // Should detect room conflict (same room, same period)
        assertTrue(result.stream().anyMatch(s -> s.contains("Room")));
    }

    @Test
    void testDetectConflictsManual_WithCapacityConflict_ShouldReturnConflictString() {
        Room smallRoom = new Room();
        smallRoom.setId(2L);
        smallRoom.setRoomNumber("102");
        smallRoom.setCapacity(10); // Too small for 25 students

        List<String> result = service.detectConflicts(testSlot1, testTeacher, smallRoom);

        assertNotNull(result);
        assertTrue(result.stream().anyMatch(s -> s.contains("capacity")));
    }

    @Test
    void testDetectConflictsManual_WithNullSlot_ShouldReturnEmptyList() {
        List<String> result = service.detectConflicts(null, testTeacher, testRoom);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testDetectConflictsManual_WithNullSchedule_ShouldReturnEmptyList() {
        testSlot1.setSchedule(null);

        List<String> result = service.detectConflicts(testSlot1, testTeacher, testRoom);

        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    @Test
    void testHasTeacherConflictManual_WithConflict_ShouldReturnTrue() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasTeacherConflict(testTeacher, 1, "DAILY", 1L);

        assertTrue(result);
    }

    @Test
    void testHasTeacherConflictManual_WithNullTeacher_ShouldReturnFalse() {
        boolean result = service.hasTeacherConflict(null, 1, "DAILY", 1L);

        assertFalse(result);
    }

    @Test
    void testHasTeacherConflictManual_WithNullPeriodNumber_ShouldReturnFalse() {
        boolean result = service.hasTeacherConflict(testTeacher, null, "DAILY", 1L);

        assertFalse(result);
    }

    @Test
    void testHasRoomConflictManual_WithConflict_ShouldReturnTrue() {
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        boolean result = service.hasRoomConflict(testRoom, 1, "DAILY", 1L);

        assertTrue(result);
    }

    @Test
    void testHasRoomConflictManual_WithNullRoom_ShouldReturnFalse() {
        boolean result = service.hasRoomConflict(null, 1, "DAILY", 1L);

        assertFalse(result);
    }

    @Test
    void testHasRoomConflictManual_WithNullPeriodNumber_ShouldReturnFalse() {
        boolean result = service.hasRoomConflict(testRoom, null, "DAILY", 1L);

        assertFalse(result);
    }

    @Test
    void testHasCapacityConflict_WithOverCapacity_ShouldReturnTrue() {
        boolean result = service.hasCapacityConflict(testRoom, 35); // Capacity is 30

        assertTrue(result);
    }

    @Test
    void testHasCapacityConflict_WithinCapacity_ShouldReturnFalse() {
        boolean result = service.hasCapacityConflict(testRoom, 25);

        assertFalse(result);
    }

    @Test
    void testHasCapacityConflict_WithNullRoom_ShouldReturnFalse() {
        boolean result = service.hasCapacityConflict(null, 25);

        assertFalse(result);
    }

    @Test
    void testHasCapacityConflict_WithNullRoomCapacity_ShouldReturnFalse() {
        testRoom.setCapacity(null);

        boolean result = service.hasCapacityConflict(testRoom, 25);

        assertFalse(result);
    }

    @Test
    void testHasCapacityConflict_WithNullEnrollment_ShouldReturnFalse() {
        boolean result = service.hasCapacityConflict(testRoom, null);

        assertFalse(result);
    }

    // ========== CAPACITY VIOLATION DETECTION ==========

    @Test
    void testDetectCapacityViolations_WithOverCapacity_ShouldReturnConflict() {
        testSlot1.setEnrolledStudents(35); // Exceeds room capacity of 30
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        assertTrue(result.stream().anyMatch(c -> "CAPACITY_CONFLICT".equals(c.getConflictType())));
    }

    @Test
    void testDetectCapacityViolations_WithNullEnrolledStudents_ShouldNotCrash() {
        testSlot1.setEnrolledStudents(null);
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        // Should not include capacity conflict
    }

    @Test
    void testDetectCapacityViolations_WithNullRoom_ShouldNotCrash() {
        testSlot1.setRoom(null);
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        // Should not crash
    }

    // ========== NULL SAFETY TESTS FOR CONFLICT CREATION ==========

    @Test
    void testConflictCreation_WithNullCourseName_ShouldUseDefault() {
        testSlot1.getCourse().setCourseName(null);
        testSlot2.getCourse().setCourseName(null);
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        // Should use "Unknown" default for course names
        assertTrue(result.stream().anyMatch(c -> c.getDescription().contains("Unknown")));
    }

    @Test
    void testConflictCreation_WithNullTeacherName_ShouldUseDefault() {
        testTeacher.setFirstName(null);
        testTeacher.setLastName(null);
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        // Should use "Unknown Teacher" default
        assertTrue(result.stream().anyMatch(c ->
            c.getDescription().contains("Unknown") || c.getDescription().contains("null")));
    }

    @Test
    void testConflictCreation_WithNullRoomNumber_ShouldUseDefault() {
        testRoom.setRoomNumber(null);
        when(scheduleSlotRepository.findByScheduleId(1L)).thenReturn(Arrays.asList(testSlot1, testSlot2));

        List<Conflict> result = service.detectConflicts(testSchedule);

        assertNotNull(result);
        // Should use "Unknown Room" default
        assertTrue(result.stream().anyMatch(c -> c.getDescription().contains("Unknown")));
    }
}
